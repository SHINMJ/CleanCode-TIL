# TIL 2022.05.08

## 오늘 읽은 범위

### **8장 경계 & 9장 단위테스트**

## 기억하고 싶은 내용 & 생각

## 8장 경계

### 캡슐화를 통해 나머지 프로그램이 설계규칙과 비즈니스 규칙을 따르도록 강제할 수 있다. <144p~145p>

```java
    Map<String, Sensor> sensors = new HashMap<>();
    ...
    Sensor s = sensors.get(sensorId);
```

Map을 사용하는 객체를 살펴보면 위와 같이 사용할 수도 있다. 위와 같은 방법은 Map 인터페이스가 변할 경우 수정할 코드가 많아진다.
또한, 값이 변경되지 않아야 하는 경우에도 메서드가 열려있기 때문에 누구든 변경할 수 있다.

```java
    public class Sensors {
        private Map<String, Sensor> sensors = new HashMap<>();

        public Sensor getById(String id) {
            return sensors.get(id);
        }

        ...
    }
```

위와 같이 경계 인터페이스인 Map을 Sensors 안으로 숨김으로써 변경에 대한 영향을 최소화 한다.

객체지향 생활체조에도 일급 컬렉션을 사용하라던지, 모든 원시값과 문자열을 포장한다는 규칙이 있다.
포장을 하면 비지니스에 종속적인 자료구조를 가질 수 있고 상태와 행위를 한 곳에서 관리할 수 있다.

### 경계살피고 익히기 <146p>

- 우리 자신을 위해 우리가 사용할 코드(외부 인터페이스에 대한)를 테스트하는 편이 바람직하다.
- 아직 존재하지 않는 코드 사용하기 <150p>
  - 경계가 명확하지 않은 경우 -> 아직 모르는, 아직 없는 영역을 분리하고 인터페이스로 정의한다. -> 하다보면 경계가 명확해진다.
- 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스를 작성한다!!! <152p>

## 9장 단위테스트

### TDD 법칙 3가지 <155p>

- 첫째 법칙: 실패하는 단위테스를 작성할 때까지 **실제 코드를 작성하지 않는다**.
- 둘째 법칙: **컴파일은 실패하지 않으면서** **실행이 실패하는 정도**로만 단위 테스트를 작성한다.
- 셋째 법칙: **현재 실패하는 테스트를 통과할 정도**로만 실제 코드를 작성한다.

### 실제코드와 맞먹을 정도롤 방대한 테스트 코드는 심각한 관리 문제를 유발한다.

### 테스트코드는 실제 코드 못지 않게 중요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다. <157p>

테스트코드를 실제 코드만큼 깨끗하게 관리해야 하는 이유!!
복잡한 테스트 코드는 변경이 일어난 경우 테스트를 추가/수정하기 어렵다. -> 테스트를 안하게 된다 -> 기능을 추가/수정하기 꺼려진다. -> 유지보수가 힘들다. -> 실패한 소프트웨어가 된다ㅠㅠ

### 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트이다. <157p>

### 깨끗한 테스트 코드를 만들려면? 가독성!가독성!가독성!!!!

BUILD-OPERATE-CHECK 패턴은 가독성을 좋게 한다.
BUILD : 테스트 자료를 만든다.
OPERATE : 테스트 자료를 조작한다.
CHECK : 조작한 결과를 확인한다.
given-when-then을 관례적으로 주석으로 사용한다!!!

### 테스트당 assert 하나!!<164p>

assert문이 하나라면 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 하지만 중복되는 코드가 많아진다.
TEMPLATE METHOD 패턴을 사용하여 중복을 제거한다.

### 테스트당 개념 하나!!<166p>

하나의 테스트에서 여러 개념을 테스트하면 코드를 이해하기 어렵다.

### F.I.R.S.T <167p>

- Fast : 테스트는 빨라야 한다.
- Independent : 각 테스트는 서로 의존하면 안된다.
- Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다.
- Self-Validating : 테스트는 bool 값으로 결과를 내야 한다.
- Timely : 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

## 오늘 읽은 소감

단위 테스트에 대한 중요성은 언제나 강조된다. 당연하다. 테스트가 있고 없고의 차이는 어마어마하다.
실제로 이전에는 테스트 코드없이 개발을 했었다. 시간이 없다는 이유로...
하지만 테스트 코드를 작성하고 개발을 진행했을 때보다 전체적인 시간이 더 느렸던 것 같다.
테스트코드가 없다 보니 오류가 발생하면 찾기 힘들고(매번 서버 실행..) 새로운 기능을 추가하거나 기능을 변경하기 위해 더 긴 테스트(통합테스트라던지..) 시간을 거쳐야 했다!!
TDD를 접하고 개발하는 습관이 달라졌다. 기본적으로 단위 테스트를 작성하다보니 경계가 어디인지 명확해지고 메서드나 클래스가 각각 어떤 책임을 하나만 가져야 하는지도 명확하게 알 수 있었다.
테스트 코드를 짜기 어렵다면 보통은 책임이 여러개였다.
정말 단위 테스트는 몇번이고 강조해도 부족하다!!!

## 궁금한 내용 or 잘 이해되지 않는 내용

### Generics

자바 1.5 버전에 추가된 것으로 일반적인 코드를 작성하고 이 코드를 다양한 타입의 객체에 대하여 재사용할 수 있도록 하는 프로그래밍 기법.
클래스나 메서드에서 사용할 타입을 외부에서 설정할 수 있도록 하여 컴파일 시에 미리 타입을 검사할 수 있다.
대표적으로 List, Set 같은 컬렉션을 사용할 때 많이 사용하고 클래스 작성 시 타입변수를 사용하고 해당 클래스를 생성할 때 타입 변수 자리에 실제 사용할 타입을 명시하도록 하여 클래스 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
제네릭을 사용하면 형변환이 필요 없다. 코드의 재사용성이 높아진다.

### 학습 테스트

API, 라이브러리, 프레임워크 등이 어떻게 동작하는지를 검증하기 위한 테스트.
다양한 조건에 따른 기능을 손쉽게 확인할 수 있다.
학습 테스트 코드를 개발 중에 참고할 수 있다.
프레임 워크나 제품을 업그레이드 할 때 호환성 검증을 할 수 있다.
테스트 작성에 대한 훈련을 할 수 있다.

### Adapter Pattern

구조 패턴 중 하나.
한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 경우 다른 인터페이스로 변환하여 사용하는 패턴으로 호환성 문제로 같이 사용할 수 없는 클래스들을 연결하여 사용할 수 있다.
여행용으로 많이 사용하는 돼지코 플러그 처럼 각 나라의 콘센트를 사용하여 충전하기 위해서 사용하는 전원 어댑터처럼 클라이언트에서 요구하는 형태의 인터페이스로 맞춰주기 위해 중간에서 연결 시켜주는 역할을 하는 클래스를 만드는 것이다.
자바에서는 `Vector, Stack` 과 같이 옛날 버전에서 사용하던 열거형을 새로운 iterator로 바꾸면서 어댑터 패턴을 사용하였다.
iterator 인터페이스를 구현하는 클래스를 만들고 해당 클래스에서 enumerator의 메서드를 호출하도록 한다.

### Tempate Method Pattern

특정 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체적인 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용을 바꾸는 패턴.
불변적인 부분은 수퍼 클래스에서 일반화하여 중복 코드를 없앤다. 이는 상속을 통해 구현할 수 있다.
