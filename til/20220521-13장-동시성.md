# TIL

## 오늘 읽은 범위

### **13장 동시성**

## 기억하고 싶은 내용 & 생각

### 동시성은 결합을 없애는 전략이다. 즉 무엇(what)과 언제(when)를 분리하는 전략이다. <226p>

### 동시성 방어 원칙

- 단일 책임의 원칙 : 동시성 코드는 다른 코드와 분리하라!! 동시성 코드는 독자적인 개발, 변경, 조율주기가 있다!!
- 자료 범위를 제한하라 : 자료를 캡슐화하라. 공유자료를 최대한 줄여라!! 임계 영역을 synchronized 키워드로 보호!!
- 자료 사본을 사용하라 <233p>
- 스레드는 가능한 독립적으로 구현하라 : 자료를 독립적인 단위로 분할하라.
- 공유 객체 하나에는 동기화 메서드 하나만 사용하라.
- 동기화하는 부분을 최대한 작게.
- 종료 코드는 개발 초기부터 고민하고 동작하게 초기부터 구현하라.

### 시스템 실패를 일회성이라 치부하지 마라.

### 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라.

### 스레드 갯수를 조율하기 쉽게 코드를 구현하라.

### 흔들기 기법을 사용해 오류를 찾아내라.

## 오늘 읽은 소감

> 동시성과 깔끔한 코드는 양립하기 어렵다. 아주 어렵다. <266p>

정말 어렵다. 다중 스레드 코드는 구현도 어렵고 깔끔하게 작성하기도 어렵다.
많은 공부를 필요로 한다.

## 궁금한 내용 or 잘 이해되지 않는 내용

### 스레드 변경에서 안전한 컬렉션 `java.util.concurrent`

- Locks: 상호 배제를 사용할 수 있는 클래스 제공
  - 내부적으로 synchronized를 사용해 구현되어 있다.
- Atomic: 동기화가 되어 있는 변수 제공
- Executors: 스레드 풀 생성, 스레드 생명 주기 관리, task 등록과 실행 등을 간편하게 처리
- Queue: 스레드에 안전한 FIFO Queue 제공
- Synchronizers: 특수한 목적의 동기화를 처리하는 5개 클래스

### 식사하는 철학자

철학자 다섯이서 원형 식탁에 둘러앉아 생각에 빠지다가, 배고플 땐 밥을 먹는다. 그들의 양쪽엔 각각 젓가락 한 짝씩 놓여있고, 밥을 먹으려 할 땐 다음의 과정을 따른다.

1. 왼쪽 젓가락부터 집어든다. 다른 철학자가 이미 왼쪽 젓가락을 쓰고 있다면 그가 내려놓을 때까지 생각하며 대기한다.
2. 왼쪽을 들었으면 오른쪽 젓가락을 든다. 들 수 없다면 1번과 마찬가지로 들 수 있을 때까지 생각하며 대기한다.
3. 두 젓가락을 모두 들었다면 일정 시간동안 식사를 한다.
4. 식사를 마쳤으면 오른쪽 젓가락을 내려놓고, 그 다음 왼쪽 젓가락을 내려놓는다.
5. 다시 생각하다가 배고프면 1번으로 돌아간다.
   위 문제는 교착상태(Deadlock)의 필요조건을 모두 가졌다.
   모든 철학자가 동시에 왼쪽 젓가락을 들어올린다면 모든 철학자는 오른쪽 젓가락을 영원히 들수 없다.

- 교착상태 필요조건
  1. 상호 배타 : 젓가락은 한번에 한 철학자만 사용할 수 있다.
  2. 보유 및 대기 : 집어든 젓가락은 계속 들은 채로 사용중인 반대쪽 젓가락을 기다린다.
  3. 비선점 : 이미 누군가 집어든 젓가락을 강제로 뺏을 수 없다.
  4. 환형대기 : 모든 철학자들이 자신의 오른쪽에 앉은 철학자가 젓가락을 놓기를 기다린다.

교착상태를 해결하기 위해서는 위 필요조건을 모두 성립하는 일이 없게끔 해야 한다. 4가지 중 하나만 어겨도 교착상태는 발생하지 않는다!!
