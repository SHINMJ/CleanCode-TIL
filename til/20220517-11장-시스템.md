# TIL

## 오늘 읽은 범위

### **11장 시스템**

## 기억하고 싶은 내용 & 생각

### 의존성 주입 <198p>

- 제어의 역전 기법을 의존성 관리에 적용한 메커니즘

### '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. <199p>

### 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다. <199p>

완벽한 설계는 없고 오늘 요구사항은 내일 폐기될 수 있다. 항상 명심하고 점진적 발전, 리팩토링 생활화를 기반으로 설계를 해야 한다..는데 잘 되지 않는다.

### 횡단 관심사 <202p>

- AOP(Aspect Oriented Programming) -> 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.
  로깅, 보안, 트랜잭션과 같은 모든 비지니스 로직에 중복으로 들어가는 로직을 모듈로써 분리하여 사용할 수 있게 한다.

### 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. <211p>

### 시스템은 도메인 특화언어가 필요하다. <212p>

### 시스템을 설계하든 개별 모듈을 설계하든 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자. <213p>

## 오늘 읽은 소감

도메인 주도 설계를 공부하고 있어서 인지 도메인 특화 언어가 필요하다는 말에 엄청 공감이 간다.
확실히 도메인 특화 언어를 사용하면 객체 지향적으로 설계가 가능한 듯 하다. 추상화된 개념을 통해 도메인 문제를 표현하고 세부적인 구현 정보는 감출 수 있어 더 명확하게 의미를 파악할 수 있다!!

## 궁금한 내용 or 잘 이해되지 않는 내용

### Spring AOP VS AspectJ

- Spring AOP

  - Spring IoC를 통한 간단한 AOP 구현이 목적이다. 완전한 AOP를 의동한 것이 아니며 spring container에 의해 관리되는 Beans에만 적용가능하다.
  - 런타임 Weaving을 사용한다.
  - proxy 기반 > 대상 객체에 Aspect를 적용하기 위해 대상 객체의 proxy를 생성한다.
  - 메서드 실행에만 joinpoint를 지원한다. > final 객체 혹은 메서드는 오버라이드할 수 없기 때문에..
  - 구현 시 다른 외장 컴파일러가 필요하지 않기 때문에 간편하다.

- AspectJ
  - 완전한 AOP를 제공하는 것이 목적인 근원적인 AOP 기술이다. 모든 객체에 적용가능하다.
  - 세가지 방식의 Weaving을 사용한다.
    - 컴파일 시점 Weaving : Aspect 코드와 애플리케이션의 소스 모두 입력받아 weaving된 class 파일을 생성한다.
    - 컴파일 후 Weaving : 바이너리 Weaving. 이미 존재하는 class 파일과 jar 파일을 weaving하기 위해 사용한다.
    - 로드 시점 Weaving : 바이너리 weaving과 유사하지만 weaving 시점이 class 파일이 jvm에 로드될 때 까지 연기된다.
  - 클래스들이 Aspect와 함께 바로 컴파일 되기 때문에 럼타임시에는 아무것도 하지 않는다.
  - 런타임 이전에 실제 코드에 weaving 하기 때문에 다양한 많은 곳에서 joinpoint를 지원한다.
  - AspectJ compiler를 도입해야 하고 모든 라이브러리들을 재 패키징해야 한다.

| Spring AOP                                              | AspectJ                                                 |
| ------------------------------------------------------- | ------------------------------------------------------- |
| 순수 java로만으로도 구현됨                              | 추가도구를 통해 구현됨                                  |
| 복잡한 과정이 필요없음                                  | 로드 시점 weaving을 사용하더라고 aspect compiler가 필요 |
| 런타임 weaving                                          | 컴파일시점,컴파일전,로드시점 weaving                    |
| 메서드 레벨의 weaving만 지원                            | 필드,메서드,생성자등 다양하게 지원                      |
| spring container에 의해 관리되는 beans에만 적용         | 모든 객체를 대상으로 적용가능                           |
| 메서드 실행 point cut만 지원                            | 모든 point cut 지원                                     |
| 대상 객체의 proxy가 생성되고 aspect는 이런 proxy에 적용 | 애플리케이션이 실행되기 전 코드에 바로 weaving          |
| AspectJ에 비해 느림(런타임에적용되므로)                 | Spring AOP에 비해 빠름(런타임 이전에 적용되므로)        |
| 배우고 적용하기 쉬움                                    | Spring AOP에 비해 복잡                                  |
